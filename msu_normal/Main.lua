SnowFlake =
{140,{1.2540383223269e-015,-20.48},{17.736200269506,-10.24},{17.736200269506,10.24},{1.2540383223269e-015,20.48},{-17.736200269506,10.24},{-17.736200269506,-10.24},{2.5080766446538e-015,-40.96},{35.47240053901,-20.48},{35.47240053901,20.48},{2.5080766446538e-015,40.96},{-35.47240053901,20.48},{-35.47240053901,-20.48},{3.7621149669806e-015,-61.44},{53.208600808516,-30.72},{53.208600808516,30.72},{3.7621149669806e-015,61.44},{-53.208600808516,30.72},{-53.208600808516,-30.72},{5.0161532893076e-015,-81.92},{70.944801078022,-40.96},{70.944801078022,40.96},{5.0161532893076e-015,81.92},{-70.944801078022,40.96},{-70.944801078022,-40.96},{6.2701916116344e-015,-102.4},{88.681001347528,-51.2},{88.681001347528,51.2},{6.2701916116344e-015,102.4},{-88.681001347528,51.2},{-88.681001347528,-51.2},{7.5242299339616e-015,-122.88},{106.41720161703,-61.44},{106.41720161703,61.44},{7.5242299339616e-015,122.88},{-106.41720161703,61.44},{-106.41720161703,-61.44},{8.778268256288e-015,-143.36},{124.15340188654,-71.68},{124.15340188654,71.68},{8.778268256288e-015,143.36},{-124.15340188654,71.68},{-124.15340188654,-71.68},{1.0032306578615e-014,-163.84},{141.88960215605,-81.92},{141.88960215605,81.92},{1.0032306578615e-014,163.84},{-141.88960215605,81.92},{-141.88960215605,-81.92},{1.1286344900942e-014,-184.32},{159.62580242555,-92.16},{159.62580242555,92.16},{1.1286344900942e-014,184.32},{-159.62580242555,92.16},{-159.62580242555,-92.16},{31.038350471634,-53.76},{46.557525707451,-44.8},{62.076700943269,-17.92},{62.076700943269,0},{62.076700943269,17.92},{46.557525707451,44.8},{31.038350471634,53.76},{15.519175235817,62.72},{4.3891341281442e-015,71.68},{-15.519175235817,62.72},{-31.038350471634,53.76},{-46.557525707451,44.8},{-62.076700943269,17.92},{-62.076700943269,7.6022033111802e-015},{-62.076700943269,-17.92},{-46.557525707451,-44.8},{-31.038350471634,-53.76},{-15.519175235817,-62.72},{-1.3167402384433e-014,-71.68},{15.519175235817,-62.72},{46.557525707451,-80.64},{62.076700943269,-71.68},{77.595876179085,-62.72},{93.115051414904,-35.84},{93.115051414904,-17.92},{93.115051414904,0},{93.115051414904,17.92},{93.115051414904,35.84},{77.595876179085,62.72},{62.076700943269,71.68},{46.557525707451,80.64},{31.038350471634,89.6},{15.519175235817,98.56},{-15.519175235817,98.56},{-31.038350471634,89.6},{-46.557525707451,80.64},{-62.076700943269,71.68},{-77.595876179085,62.72},{-93.115051414904,35.84},{-93.115051414904,17.92},{-93.115051414904,1.140330496677e-014},{-93.115051414904,-17.92},{-93.115051414904,-35.84},{-77.595876179085,-62.72},{-62.076700943269,-71.68},{-46.557525707451,-80.64},{-31.038350471634,-89.6},{-15.519175235817,-98.56},{15.519175235817,-98.56},{31.038350471634,-89.6},{15.519175235817,-142.08},{-15.519175235817,-142.08},{-115.28530175178,-84.48},{-130.8044769876,-57.6},{-130.8044769876,57.6},{-115.28530175178,84.48},{-15.519175235817,142.08},{15.519175235817,142.08},{115.28530175178,84.48},{130.8044769876,57.6},{130.8044769876,-57.6},{115.28530175178,-84.48},{31.038350471634,-151.04},{-31.038350471634,-151.04},{-115.28530175178,-102.4},{-146.32365222342,-48.64},{-146.32365222342,48.64},{-115.28530175178,102.4},{-31.038350471634,151.04},{31.038350471634,151.04},{115.28530175178,102.4},{146.32365222342,48.64},{146.32365222342,-48.64},{115.28530175178,-102.4},{46.557525707451,-160},{-46.557525707451,-160},{-115.28530175178,-120.32},{-161.84282745924,-39.68},{-161.84282745924,39.68},{-115.28530175178,120.32},{-46.557525707451,160},{46.557525707451,160},{115.28530175178,120.32},{161.84282745924,39.68},{161.84282745924,-39.68},{115.28530175178,-120.32}}




-- Copy from here
-- --- Laptop
-- Curdir = "C:\\Users\\rlatj\\Desktop\\workingarea\\mapping\\euddraft0.9.10.12\\Mapping"
-- __MapDirSetting(__encode_cp949(Curdir)) -- 맵파일 경로(\를 \\로 바꿔야함)
-- __SubDirSetting(__encode_cp949(Curdir.."\\msu")) -- Main.lua 폴더경로 (\를 \\로 바꿔야함, 없으면 비우기)

--- Desktop
Curdir = "C:\\Users\\USER\\Desktop\\mapping\\euddraft0.9.10.12\\Mapping"
__MapDirSetting(__encode_cp949("C:\\Users\\USER\\Desktop\\mapping\\euddraft0.9.10.12\\Mapping")) -- 맵파일 경로(\를 \\로 바꿔야함)
__SubDirSetting(__encode_cp949(Curdir.."\\msu")) -- Main.lua 폴더경로 (\를 \\로 바꿔야함, 없으면 비우기)
-- End of VSC Compile Mode Initialization


--↓ Tep에 그대로 붙여넣기----------------------------------------
FP = P8
SetForces({P1,P2,P3,P4},{P5,P6,P7,P8},{},{},{P1,P2,P3,P4,P5,P6,P7,P8}) 
SetFixedPlayer(P8)
-- StartCtrig(1,nil,0,1,"C:\\Users\\rlatj\\Desktop\\workingarea\\mapping\\euddraft0.9.10.12")
StartCtrig(1,nil,0,1,"C:\\Users\\USER\\Desktop\\mapping\\euddraft0.9.10.12")
CJump(AllPlayers,0)

Include_DataTransfer()
Include_CBPaint()
Include_CtrigPlib(360,"Switch 254",1)
Include_64BitLibrary("Switch 255")
Install_GetCLoc(FP,253,184)
CSPlotIndexAlloc = 1
CSPlotOrderIndexAlloc = 1

function CallTriggerFPX(Player,Index,Condition,AddonTrigger,Flags) -- CtrigAsm 5.1
	local Y
	if Flags == nil then Y = {preserved} elseif Flags == "X" or Flags == 1 then Y = {} else PushErrorMsg("CallTriggerX_FlagError") end
	local X = {
        SetCtrigX(nil,"X",0x4,0,SetTo,FP,Index,0x0,0,0);
        SetCtrigX(FP,Index+1,0x4,0,SetTo,nil,"X",0x0,0,1);
    }
	table.insert(X,SetCtrigX(FP,Index+1,0x158,0,SetTo,"X","X",0x4,1,0))
	table.insert(X,SetCtrigX(FP,Index+1,0x15C,0,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrig1X(FP,Index+1,0x164,0,SetTo,0x0,0x2))
	TriggerX(Player,Condition,{AddonTrigger,X},Y)
end

function CSPlotOrder(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,OrderShape,Direction,OrderType,OrderLocation,DestXY,SizeofLoc,PerAction,PlayerID,Condition,Action,Preserve)
    --    CA : (=CAPlotDataArr) : 1st CAPlot전용내부변수총14개
    --    CB : (=CAPlotCreateArr) : 2nd CAPlot전용내부변수총10개
    --    PlayerID: (=CAPlotPlayerID) : CAPlot전용트리거플레이어
    --    CA[1] = 그릴도형선택(k 입력시k번Shape 데이터로초기화)
    --     CA[2] = 남은대기시간(Tick 단위/ 0일때유닛소환)
    --     CA[3] = 소환후대기시간증가량(Tick 단위/ k입력시1회루프후대기시간k추가)
    --     CA[4] = 루프카운터(트리거순환당루프수를카운트함)
    --     CA[5] = 루프리미트(트리거순환당소환할유닛수/ k입력시CA[4] : 0~k-1까지루프함)
    --     CA[6] = 데이터인덱스(k입력시Shape[k+1]의데이터를출력함)
    --     CA[7] = 임시변수: ConvertArr(CA[6]) -사용금지
    --    CA[8] = 임시변수: Shape[k+1][1] -현재출력할유닛의X좌표
    --    CA[9] = 임시변수: Shape[k+1][2] -현재출력할유닛의Y좌표
    --    CA[10] = 임시변수: 선택된Shape의Max Index (k입력시CA[6] > k면Plot 종료) -k≥1
    --     CA[11] ~ CA[14] : 임시변수로자유롭게사용가능(※ 주의: CA_Rotate3D 사용시값이변경될수있음)
    --     CB[1] = PerUnit (16777216*k 입력시k마리씩소환)
    --     CB[2] = UnitId(k입력시k번유닛을소환)
    --     CB[3] = Owner (k입력시P(k+1)플레이어의유닛을소환)
    --     CB[4] ~ CB[10] : 임시변수로자유롭게사용가능(CA_ 함수에서도사용하니주의)
    --     / CB[10] > 0일경우해당점을Skip함
    --    CC[1] = 목적지도형선택(k 입력시k번OrderShape데이터로초기화)
    --     CC[2] = 목적지데이터인덱스(k입력시OrderShape[k+1]의데이터로명령내림)
    --     CC[3] = 임시변수: ConvertArr(CC[2]) -사용금지
    LSize = 0
    if PlotSize ~= nil then
        LSize = LSize+PlotSize
    end
    if SizeofLoc ~= nil then
        LSize = LSize+SizeofLoc
    end
	local LocId = Location
	if type(Location) == "string" then
		LocId = ParseLocation(LocId)-1
	end
    
	local OLocId = OrderLocation
	if type(OrderLocation) == "string" then
		OLocId = ParseLocation(OLocId)-1
	end
    if type(UnitId) == "string" then
        UnitId = ParseUnit(UnitId) -- 스트링으로 유닛이름 입력가능
    end
    --CAPlotOrderForward() = {CA[1],CA[2],CA[3],CA[4],CA[5],CA[6],CB[1],CB[2],CB[3],CC[1],CC[2]} 

    if CSPlotShapeArr[Shape] == nil then
        CSPlotShapeArr[Shape] = {Shape,CSPlotIndexAlloc}
        CSPlotIndexAlloc = CSPlotIndexAlloc + 1
    end
    Shape = CSPlotShapeArr[Shape][2]
    if CSPlotShapeArr[OrderShape] == nil then
        CSPlotShapeArr[OrderShape] = {OrderShape,CSPlotOrderIndexAlloc}
        CSPlotOrderIndexAlloc = CSPlotOrderIndexAlloc + 1
    end
    local ACCX = SetCVar(FP, CCX[2], SetTo, 0xFFFFFFFF)
    local ACCY = SetCVar(FP, CCY[2], SetTo, 0xFFFFFFFF)
    if CenterXY ~= nil then
        ACCX = SetCVar(FP, CCX[2], SetTo, CenterXY[1])
        ACCY = SetCVar(FP, CCY[2], SetTo, CenterXY[2])
    end
    local DACCX = SetCVar(FP, DCCX[2], SetTo, 0xFFFFFFFF)
    local DACCY = SetCVar(FP, DCCY[2], SetTo, 0xFFFFFFFF)
    if CenterXY ~= nil then
        DACCX = SetCVar(FP, DCCX[2], SetTo, DestXY[1])
        DACCY = SetCVar(FP, DCCY[2], SetTo, DestXY[2])
    end
    OrderShape = CSPlotShapeArr[OrderShape][2]
    local Act = {
        SetCVar(FP, CCA[1][2], SetTo, Shape),
        SetCVar(FP, CCA[10][2], SetTo, OrderShape),
        SetCVar(FP, CCA[9][2], SetTo, Owner),
        SetCVar(FP, CCA[8][2], SetTo, UnitId),
        SetCVar(FP, CCA[7][2], SetTo, PerUnit*16777216),
        SetCVar(FP, CALocation[2], SetTo, LocId+1),
        SetCVar(FP, CAOrderLocation[2], SetTo, OLocId+1),
        SetCVar(FP, CLSize[2], SetTo, LSize),
        SetCVar(FP, COrder[2], SetTo, OrderType),
        ACCX,
        ACCY,
        DACCX,
        DACCY,


    }
    CallTriggerFPX(PlayerID, Call_CSPlotToCAPlot, Condition, Act, Preserve)

end
CCX,CCY= CreateVars(2, FP)
DCCX,DCCY = CreateVars(2, FP)
CCA = CreateVarArr(11, FP)
CALocation = CreateVar(FP)
CAOrderLocation = CreateVar(FP)
COrder = CreateVar(FP)
CLSize = CreateVar(FP)
Call_CSPlotToCAPlot = CreateCallIndex()
CSPlotShapeArr = {}
CSPlotOShapeArr = {}

-- Include_MatheMatics(360)
---- Calculating death variable ----
SDspeed = 1000 // 29

P_Count = CreateNcode()
HumanPlayers = {P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12}

CJumpEnd(AllPlayers,0)
Enable_PlayerCheck()
ObserverChatToAll(FP, _Void(0xFF), nil, nil, 0)
NoAirCollisionX(FP)
DoActions(FP,{SetSpeed(SetTo, "#X2")})

-- TriggerX(FP, Always(), {SetResources(P1, SetTo, 1000000, Ore)}, preserved)
-- TriggerX(FP, Always(), {CreateUnit(132, 1, "hive10", P1)})

Install_function()
Install_verifingPhase()
Install_plotshape()
Install_opening()
check_shape()
for i = 4, 7 do
    TriggerX(Force2, Always(), {SetMemoryB(0x58F32C + (i * 15) + 4, SetTo, 255)})
end
for i = 0, 3 do
    TriggerX(Force1, Always(), {SetMemoryB(0x58D088 + (i * 46) + 15, SetTo, 255)})
end
TriggerX(FP, {Switch("Switch 249", Set)}, {SetMemoryBA(0x657A9C, SetTo, 31)})
CIf(AllPlayers,{Switch("Switch 248", Set)})

Install_initial_system_setting()
Install_APMcounter()
Install_normalGunplot()
Install_SpecialGunplot()
Install_ExchangeTrigger()
Install_WaveTrigger()
Install_HealZoneTrigger()
Install_Neutral_bunkerTrigger()
Install_DonateNbanTrigger()
Install_ConvertMarineTrigger()
Install_CCMU()
Install_BGMPhase()
Install_HerounitTrigger()
Install_NormalGunPlotShape()
Install_SpecialGunPlotShape()
MiddleBossTrigger()
FinalBossTrigger()

CIfEnd()

function CSPlotToCAPlot()
    CAPlotJump = def_sIndex()
    CJump(FP, CAPlotJump)
    local Z = {}
    local c = 0
    for j,k in pairs(CSPlotShapeArr) do
        Z[k[2]] = k[1]
        c=c+1
        G_CB_ShNm = G_CB_ShNm+1
    end
    local Y = {}
    local c = 0
    for j,k in pairs(CSPlotOShapeArr) do
        Y[k[2]] = k[1]
        c=c+1
        G_CB_ShNm = G_CB_ShNm+1
    end

    SetCall2(FP, Call_CSPlotToCAPlot)
    CA = CAPlotOrderForward()
    --CCX,CCY= CreateVars(2, FP)
    --DCCX,DCCY = CreateVars(2, FP)
    --CCA = CreateVarArr(11, FP)
    --CALocation = CreateVar(FP)
    --CAOrderLocation = CreateVar(FP)
    --COrder = CreateVar(FP)
    --CLSize = CreateVar(FP)

        CIfX(FP, {
        CVar(FP, CCX[2], Exactly, 0xFFFFFFFF),
        CVar(FP, CCY[2], Exactly, 0xFFFFFFFF)
    })
    TGetLocCenter(CALocation,CCX,CCY)
    CIfXEnd()
    CIfX(FP, {
        CVar(FP, DCCX[2], Exactly, 0xFFFFFFFF),
        CVar(FP, DCCY[2], Exactly, 0xFFFFFFFF)
    })
    TGetLocCenter(CAOrderLocation,DCCX,DCCY)
    CIfXEnd()
    local function CAFunc1()
        Simple_SetLocX(FP, 250, CCX, CCY, CCX, CCY)
        Simple_CalcLocX(FP, 250, V(CA[8]), V(CA[9]), V(CA[8]), V(CA[9]))
        Simple_CalcLocX(FP, 250, _Neg(CLSize), _Neg(CLSize), CLSize, CLSize)
        CDoActions(FP, {TCreateUnit(CCA[7], CCA[8], 251, CCA[9])})
    end
    local function CBFunc1()
        Simple_SetLocX(FP, 251, DCCX, DCCY, DCCX, DCCY)
        Simple_CalcLocX(FP, 251, V(CA[8]), V(CA[9]), V(CA[8]), V(CA[9]))
        Simple_CalcLocX(FP, 251, _Neg(CLSize), _Neg(CLSize), CLSize, CLSize)
        CTrigger(FP, {CVar(FP, COrder[2], Exactly, Attack)}, {TOrder(CCA[8], CCA[9], 251, Attack, 252)}, {preserved})
        CTrigger(FP, {CVar(FP, COrder[2], Exactly, Move)}, {TOrder(CCA[8], CCA[9], 251, Move, 252)}, {preserved})
        CTrigger(FP, {CVar(FP, COrder[2], Exactly, Patrol)}, {TOrder(CCA[8], CCA[9], 251, Patrol, 252)}, {preserved})
    end
    CAPlotOrder(Z, FP, 184, 249, {0,0}, 1, 32, {CCA[1],0,0,0,0,1}, "CAFunc1", Y, Attack, 249, {0,0}, {CCA[10],1}, "CBFunc1", 32, FP, {}, {}, 1)
    SetCallEnd()
    CJumpEnd(FP, CAPlotJump)
    
end

CSPlotToCAPlot()


EndCtrig()
ErrorCheck()
EUDTurbo(FP)
-- 에러 체크 함수 선언 위치 --
--↑Tep에 그대로 붙여넣기-----



-- for i = 0, 10 do
-- if i%2 == 0 then
-- Trigger {
-- 	players = {P1},
-- 	conditions = {
-- 		Memory(0x640B60+0xDA*i, Exactly, 0xEABDB2EA);
-- 		Memory(0x640B64+0xDA*i, Exactly, 0x203AA0B3);	
-- 	},
-- 	actions = {
-- 		SetMemory(0x640B60+0xDA*i,SetTo,0);
-- 		PreserveTrigger();
-- 	}
-- }
-- Trigger {
-- 	players = {P1},
-- 	conditions = {
-- 		Memory(0x640B60+0xDA*i, Exactly, 0x4E524157);
-- 		Memory(0x640B64+0xDA*i, Exactly, 0x3A474E49);	
-- 	},
-- 	actions = {
-- 		SetMemory(0x640B60+0xDA*i,SetTo,0);
-- 		PreserveTrigger();
-- 	}
-- }
-- else
-- Trigger {
-- 	players = {P1},
-- 	conditions = {
-- 		MemoryX(0x640B5E + 0xDA*i, Exactly, 0xB2EA0000,0xFFFF0000);
-- 		Memory(0x640B62 + 0xDA*i, Exactly, 0xA0B3EABD);	
-- 		MemoryX(0x640B66 + 0xDA*i, Exactly, 0x203A,0xFFFF);
-- 	},
-- 	actions = {
-- 		SetMemory(0x640B5E + 0xDA*i,SetTo,0);
-- 		PreserveTrigger();
-- 	}
-- }
-- Trigger {
-- 	players = {P1},
-- 	conditions = {
-- 		MemoryX(0x640B5E + 0xDA*i, Exactly, 0x41570000,0xFFFF0000);
-- 		Memory(0x640B62 + 0xDA*i, Exactly, 0x4E494E52);	
-- 		MemoryX(0x640B66 + 0xDA*i, Exactly, 0x00003A47,0xFFFF);
-- 	},
-- 	actions = {
-- 		SetMemory(0x640B5E + 0xDA*i,SetTo,0);
-- 		PreserveTrigger();
-- 	}
-- }
-- end
-- end

--[[
1. Compile 후 시나리오 손상은 특정 trigger의 문제일 가능성이 농후하다.
TEP3.0 기반 트리거 자체가 트리거 용량을 많이 잡아먹어서 어쩔수없는문제. Freeze를 끄면 어느정도 해결이 된다고 함. Mininii님 피셜 

2. 중벙 트리거 관련. 중벙 안에 있는 유닛은 Men 감지를 받아서 안에있는데 갑자기 P12로 뺏기거나 하는일은 절대없음

3. 이펙트쓰다가 데스값때문에 스캔 이미지값 꼬일수있으니 웬만하면 그냥 보스페이즈 아니면 드래그방지 플래그 걸고 유닛으로 이펙트 내는게 좋다고함.

4. CSPlot Action은 해당 줄의 CSPlot 도형 실행후, Execute 하는 단락임.



]]